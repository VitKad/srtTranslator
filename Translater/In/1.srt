1
00:00:00,000 --> 00:00:03,141
Мы уже рассмотрели довольно много концепций. Вернемс

2
00:00:03,141 --> 00:00:06,282
я в Visual Studio и посмотрим, как все это реализова

3
00:00:06,282 --> 00:00:09,423
ть. Мы добавим MediatR и AutoMapper. Затем мы создад

4
00:00:09,423 --> 00:00:12,564
им запрос и обработчик запроса, а также  наконец, мы

5
00:00:12,564 --> 00:00:15,705
 подготовим все, чтобы наши библиотеки могли быть за

6
00:00:15,705 --> 00:00:18,845
регистрированы в коллекции сервисов. Если бы мне пла

7
00:00:18,845 --> 00:00:21,986
тили за добавление новых файлов и новых контрактов, 

8
00:00:21,986 --> 00:00:25,127
то я бы уже сегодня заработал немало денег, но тольк

9
00:00:25,127 --> 00:00:28,268
о на контрактах, это не очень полезно.  Нам нужно бу

10
00:00:28,268 --> 00:00:31,409
дет написать некоторый код реализации, и это то, что

11
00:00:31,409 --> 00:00:34,550
 я собираюсь сделать дальше. Итак, теперь мы собирае

12
00:00:34,550 --> 00:00:37,691
мся вместе написать бизнес-логику, чтобы получить сп

13
00:00:37,691 --> 00:00:40,832
исок всех событий, и давайте сделаем это.  следующий

14
00:00:40,832 --> 00:00:43,973
. Итак, чтобы написать наш бизнес-код, мне понадобит

15
00:00:43,973 --> 00:00:47,114
ся пара пакетов. На самом деле я буду использовать A

16
00:00:47,114 --> 00:00:50,255
utoMapper и MediatR, как описано на слайдах. AutoMap

17
00:00:50,255 --> 00:00:53,395
per будет использоваться для сопоставления между сущ

18
00:00:53,395 --> 00:00:56,536
ностями, а MediatR будет использоваться  использоват

19
00:00:56,536 --> 00:00:59,677
ься для написания этих запросов и обработчиков запро

20
00:00:59,677 --> 00:01:02,818
сов, то есть сообщения и обработчика сообщений. Чтоб

21
00:01:02,818 --> 00:01:05,959
ы упростить задачу, я перейду к своему проекту прило

22
00:01:05,959 --> 00:01:09,100
жения и внесу еще одну группу элементов, содержащую 

23
00:01:09,100 --> 00:01:12,241
ссылки на  пакеты, которые мне понадобятся. Поэтому 

24
00:01:12,241 --> 00:01:15,382
я добавил AutoMapper с расширением для внедрения зав

25
00:01:15,382 --> 00:01:18,523
исимостей, а также MediatR. Если я сохраню этот файл

26
00:01:18,523 --> 00:01:21,664
, вы также сможете увидеть в диспетчере пакетов NuGe

27
00:01:21,664 --> 00:01:24,805
t, что эти пакеты действительно были добавлены в мой

28
00:01:24,805 --> 00:01:27,945
 проект. Итак,  сейчас я оберну то, что собираюсь сд

29
00:01:27,945 --> 00:01:31,086
елать, в тип, и это будет мой запрос, и я хочу получ

30
00:01:31,086 --> 00:01:34,227
ить все события в списке. Итак, это происходит  быть

31
00:01:34,227 --> 00:01:37,368
, скажем, сообщением о том, что я хочу сделать. Я хо

32
00:01:37,368 --> 00:01:40,509
чу получить список всех событий. Итак, я собираюсь о

33
00:01:40,509 --> 00:01:43,650
бернуть это в тип, который будет называться GetEvent

34
00:01:43,650 --> 00:01:46,791
sListQuery, я  вызываю его запросом, потому что я хо

35
00:01:46,791 --> 00:01:49,932
чу что-то получить, и я хочу получить этот список вс

36
00:01:49,932 --> 00:01:53,073
ех событий. Поэтому мне нужно сделать этот класс соо

37
00:01:53,073 --> 00:01:56,214
бщением, и я собираюсь сделать это, разрешив ему реа

38
00:01:56,214 --> 00:01:59,355
лизовать интерфейс IRequest.  Параметр типа, то есть

39
00:01:59,355 --> 00:02:02,495
 для IRequest, будет типом данных, которые этот запр

40
00:02:02,495 --> 00:02:05,636
ос будет возвращать, и это будет список виртуальных 

41
00:02:05,636 --> 00:02:08,777
машин со списком событий. Это еще один класс, которы

42
00:02:08,777 --> 00:02:11,918
й я собираюсь  для возврата, и я собираюсь создать о

43
00:02:11,918 --> 00:02:15,059
пределенный тип ViewModel, который я собираюсь верну

44
00:02:15,059 --> 00:02:18,200
ть для своего клиентского приложения. Это будет View

45
00:02:18,200 --> 00:02:21,341
Model, который будет содержать только свойства для в

46
00:02:21,341 --> 00:02:24,482
изуализации его в списке,  достаточно информации, чт

47
00:02:24,482 --> 00:02:27,623
обы я не возвращал слишком много данных. Это означае

48
00:02:27,623 --> 00:02:30,764
т, что я добавлю сюда класс, потому что я его еще не

49
00:02:30,764 --> 00:02:33,905
 создал. Это будет новый класс, и он будет называтьс

50
00:02:33,905 --> 00:02:37,045
я EventListVm, и  как я уже сказал, он будет содержа

51
00:02:37,045 --> 00:02:40,186
ть данные, которые я хочу визуализировать для событи

52
00:02:40,186 --> 00:02:43,327
я, когда оно отображается в списке. Он содержит толь

53
00:02:43,327 --> 00:02:46,468
ко несколько базовых свойств, а не все свойства собы

54
00:02:46,468 --> 00:02:49,609
тия, а только те, которые мне понадобятся.  в списке

55
00:02:49,609 --> 00:02:52,750
 здесь Андур _____ здесь тоже удовлетворен, так что 

56
00:02:52,750 --> 00:02:55,891
это сообщение. Мне также понадобится обработчик сооб

57
00:02:55,891 --> 00:02:59,032
щения, который будет запускаться, скажем, при отправ

58
00:02:59,032 --> 00:03:02,173
ке этого сообщения, и который будет содержать фактич

59
00:03:02,173 --> 00:03:05,314
ескую бизнес-логику. Итак  этот обработчик будет зап

60
00:03:05,314 --> 00:03:08,455
ускаться MediatR. Итак, я собираюсь создать еще один

61
00:03:08,455 --> 00:03:11,595
 класс, и это будет обработчик GetEventsListQuery, о

62
00:03:11,595 --> 00:03:14,736
брабатывающий GetEventsListQuery. Это будет еще один

63
00:03:14,736 --> 00:03:17,877
 класс, который теперь должен реализовать другой инт

64
00:03:17,877 --> 00:03:21,018
ерфейс из MediatR.  Итак, указав здесь, что это реал

65
00:03:21,018 --> 00:03:24,159
изует обработчик IRequesthandler в GetEventsListQuer

66
00:03:24,159 --> 00:03:27,300
y, это мой тип сообщения, и он будет возвращать спис

67
00:03:27,300 --> 00:03:30,441
ок виртуальных машин списка событий. Теперь он все е

68
00:03:30,441 --> 00:03:33,582
ще дает мне красную волнистую линию. Это нормально, 

69
00:03:33,582 --> 00:03:36,723
потому что мне все еще нужно реализовать  метод, ког

70
00:03:36,723 --> 00:03:39,864
да я собираюсь обработать сообщение, и этот метод фа

71
00:03:39,864 --> 00:03:43,005
ктически называется Handle. Таким образом, этот мето

72
00:03:43,005 --> 00:03:46,145
д будет вызываться автоматически, когда aGetEventsLi

73
00:03:46,145 --> 00:03:49,286
stQuery будет запущен, и этот обработчик подхватит е

74
00:03:49,286 --> 00:03:52,427
го. Итак, он будет содержать мою реализованную бизне

75
00:03:52,427 --> 00:03:55,568
с-логику  здесь. Я вставил код и позвольте мне тепер

76
00:03:55,568 --> 00:03:58,709
ь рассказать вам об этом. В конструкторе я вхожу в к

77
00:03:58,709 --> 00:04:01,850
артограф;  это AutoMapper, как вы можете видеть здес

78
00:04:01,850 --> 00:04:04,991
ь. Я также собираюсь использовать IAsyncRepository в

79
00:04:04,991 --> 00:04:08,132
 событиях. Действительно, этот обработчик запросов я

80
00:04:08,132 --> 00:04:11,273
вляется моей бизнес-логикой, и он будет работать с р

81
00:04:11,273 --> 00:04:14,414
епозиториями, чтобы получить список событий. С конст

82
00:04:14,414 --> 00:04:17,555
руктором  инъекции, я собираюсь получить экземпляры 

83
00:04:17,555 --> 00:04:20,695
_eventRepository и AutoMapper. Теперь настоящее волш

84
00:04:20,695 --> 00:04:23,836
ебство происходит здесь, в методе Handle, который я 

85
00:04:23,836 --> 00:04:26,977
установил. Я собираюсь использовать свой репозиторий

86
00:04:26,977 --> 00:04:30,118
 событий. На самом деле я собираюсь использовать Lis

87
00:04:30,118 --> 00:04:33,259
tAllAsync  метод, который мы определили в IAsyncRepo

88
00:04:33,259 --> 00:04:36,400
sitory, то есть базовый интерфейс, и я собираюсь пол

89
00:04:36,400 --> 00:04:39,541
учить все события, упорядоченные по дате. Это дает м

90
00:04:39,541 --> 00:04:42,682
не список сущностей, IOrderedEnumerable событий, поэ

91
00:04:42,682 --> 00:04:45,823
тому сущности домена. Теперь я не хочу  для возврата

92
00:04:45,823 --> 00:04:48,964
 объектов моим клиентам. Я хочу возвращать объекты, 

93
00:04:48,964 --> 00:04:52,105
которые я контролирую, чтобы они содержали только те

94
00:04:52,105 --> 00:04:55,245
 свойства, которые я хочу вернуть, и они были доступ

95
00:04:55,245 --> 00:04:58,386
ны в моем EventListVm. Теперь я не хочу писать сопос

96
00:04:58,386 --> 00:05:01,527
тавление  Я тоже напишу код, поэтому я собираюсь исп

97
00:05:01,527 --> 00:05:04,668
ользовать для этого AutoMapper. И в AutoMapper я мог

98
00:05:04,668 --> 00:05:07,809
у использовать метод Map, как вы видите здесь, и я м

99
00:05:07,809 --> 00:05:10,950
огу указать тип, который я хочу сопоставить, то есть

100
00:05:10,950 --> 00:05:14,091
 список EventListVms  .И я собираюсь использовать al

101
00:05:14,091 --> 00:05:17,232
lEvents в качестве объекта, из которого я хочу сопос

102
00:05:17,232 --> 00:05:20,373
тавить. Итак, что будет возвращено, это список ViewM

103
00:05:20,373 --> 00:05:23,514
odels списка событий. Теперь AutoMapper нужна дополн

104
00:05:23,514 --> 00:05:26,655
ительная информация, чтобы это действительно работал

105
00:05:26,655 --> 00:05:29,795
о. Это так.  нужно то, что известно как профиль. Про

106
00:05:29,795 --> 00:05:32,936
филь будет содержать информацию о сопоставлении, что

107
00:05:32,936 --> 00:05:36,077
бы AutoMapper знал, действительно ли он должен иметь

108
00:05:36,077 --> 00:05:39,218
 возможность попытаться сопоставить этот тип с други

109
00:05:39,218 --> 00:05:42,359
м типом. Теперь AutoMapper выполняет большую часть р

110
00:05:42,359 --> 00:05:45,500
аботы автоматически, но иногда вам может потребовать

111
00:05:45,500 --> 00:05:48,641
ся помощь.  немного, но если свойства в EventListVm 

112
00:05:48,641 --> 00:05:51,782
имеют те же имена, что и свойства в реальном объекте

113
00:05:51,782 --> 00:05:54,923
, тогда он сам выполнит сопоставление. Если мы затем

114
00:05:54,923 --> 00:05:58,064
 просто создадим профиль, сопоставление будет выполн

115
00:05:58,064 --> 00:06:01,205
ено автоматически для нас, если мы определим это  в 

116
00:06:01,205 --> 00:06:04,345
профиле, то есть. Итак, я собираюсь вернуться к свое

117
00:06:04,345 --> 00:06:07,486
му проекту приложения и создать папку с именем Profi

118
00:06:07,486 --> 00:06:10,627
les. Теперь профиля действительно нечего бояться. Эт

119
00:06:10,627 --> 00:06:13,768
о просто простой класс, который содержит  что AutoMa

120
00:06:13,768 --> 00:06:16,909
pper должен знать с точки зрения сопоставления между

121
00:06:16,909 --> 00:06:20,050
 типами. Я назову это здесь классом MappingProfile. 

122
00:06:20,050 --> 00:06:23,191
Как я уже сказал, это просто класс, и он должен насл

123
00:06:23,191 --> 00:06:26,332
едовать от базового класса Profile. Это класс, котор

124
00:06:26,332 --> 00:06:29,473
ый приходит  с AutoMapper. В конструкторе я собираюс

125
00:06:29,473 --> 00:06:32,614
ь написать свои сопоставления. Я собираюсь создать с

126
00:06:32,614 --> 00:06:35,755
опоставление между Event и EventListVm, и я собираюс

127
00:06:35,755 --> 00:06:38,895
ь указать, что оно должно иметь возможность знать об

128
00:06:38,895 --> 00:06:42,036
 этом сопоставлении двумя способами.  Итак, от Event

129
00:06:42,036 --> 00:06:45,177
 к EventListVm и наоборот, что я делаю здесь, исполь

130
00:06:45,177 --> 00:06:48,318
зуя ReverseMap. По мере продвижения мы добавим больш

131
00:06:48,318 --> 00:06:51,459
е профилей сопоставления. Я хочу отметить здесь еще 

132
00:06:51,459 --> 00:06:54,600
одну вещь. Итак, мы можем видеть здесь, я  использов

133
00:06:54,600 --> 00:06:57,741
ал IAsyncRepository в Event. Конечно, у нас пока нет

134
00:06:57,741 --> 00:07:00,882
 реализации;  который будет подключен с помощью внед

135
00:07:00,882 --> 00:07:04,023
рения зависимостей, по сути, это реализация инверсии

136
00:07:04,023 --> 00:07:07,164
 зависимостей. Нам все еще нужно написать реальный р

137
00:07:07,164 --> 00:07:10,305
епозиторий, который знает, как обрабатывать это в ба

138
00:07:10,305 --> 00:07:13,445
зе данных. Сейчас у нас его еще нет, но вы можете ув

139
00:07:13,445 --> 00:07:16,586
идеть это в приложении  проект, мы просто говорим с 

140
00:07:16,586 --> 00:07:19,727
абстракцией. Это то, что будет делать проект приложе

141
00:07:19,727 --> 00:07:22,868
ния, просто говорить с абстракциями. Я думаю, что на

142
00:07:22,868 --> 00:07:26,009
 данный момент моя реализация GetEventList более или

143
00:07:26,009 --> 00:07:29,150
 менее готова. Надеюсь, вы уже это поняли.  , и я со

144
00:07:29,150 --> 00:07:32,291
бираюсь добавить еще один для получения подробностей

145
00:07:32,291 --> 00:07:35,432
 о событии и покажу вам результат. Теперь я добавил 

146
00:07:35,432 --> 00:07:38,573
несколько дополнительных классов, которые будут испо

147
00:07:38,573 --> 00:07:41,714
льзоваться для получения подробностей о событии.  Ит

148
00:07:41,714 --> 00:07:44,855
ак, у меня есть еще один запрос, GetEventDetail, кот

149
00:07:44,855 --> 00:07:47,995
орый будет немного отличаться от нашего запроса GetE

150
00:07:47,995 --> 00:07:51,136
ventsListQuery в том смысле, что GetEventDetailQuery

151
00:07:51,136 --> 00:07:54,277
 содержит дополнительный параметр. Мне нужно знать, 

152
00:07:54,277 --> 00:07:57,418
какие сведения о событии мне нужно получить. Мы обер

153
00:07:57,418 --> 00:08:00,559
нули его здесь.  идентификатор Guid. Обратите вниман

154
00:08:00,559 --> 00:08:03,700
ие, что IRequest теперь будет общим в EventDetailVm,

155
00:08:03,700 --> 00:08:06,841
 поэтому тип возвращаемого значения будет другой вир

156
00:08:06,841 --> 00:08:09,982
туальной машиной, другой ViewModel, которая содержит

157
00:08:09,982 --> 00:08:13,123
 больше свойств о событии, то есть подробную информа

158
00:08:13,123 --> 00:08:16,264
цию о событии. Обратите внимание, что я  здесь есть 

159
00:08:16,264 --> 00:08:19,405
вложенная сущность под названием CategoryDto. Мне та

160
00:08:19,405 --> 00:08:22,545
кже нужно знать информацию о категории этого события

161
00:08:22,545 --> 00:08:25,686
. Это другой тип. Это снова не будет фактическая сущ

162
00:08:25,686 --> 00:08:28,827
ность категории, которую я собираюсь вернуть. Я соби

163
00:08:28,827 --> 00:08:31,968
раюсь  возвращать вложенную категорию CategoryDto, с

164
00:08:31,968 --> 00:08:35,109
одержащую идентификатор и имя этой категории, которы

165
00:08:35,109 --> 00:08:38,250
е мне нужно вернуть для получения подробной информац

166
00:08:38,250 --> 00:08:41,391
ии о событии. Теперь сюда также включен обработчик G

167
00:08:41,391 --> 00:08:44,532
etEventDetailQuery, и я расскажу вам и об этом. Это 

168
00:08:44,532 --> 00:08:47,673
снова обработчик IRequest, который  теперь будет ини

169
00:08:47,673 --> 00:08:50,814
циироваться GetEventDetailQuery и будет возвращать н

170
00:08:50,814 --> 00:08:53,955
е список EventListVms, а один EventDetailVm. Мы соби

171
00:08:53,955 --> 00:08:57,095
раемся снова использовать _eventRepository, но мы та

172
00:08:57,095 --> 00:09:00,236
кже собираемся использовать _categoryRepository, и м

173
00:09:00,236 --> 00:09:03,377
ы  собираюсь снова использовать AutoMapper. Конструк

174
00:09:03,377 --> 00:09:06,518
тор снова будет использовать внедрение зависимостей,

175
00:09:06,518 --> 00:09:09,659
 чтобы позже подключить конкретные реализации этих р

176
00:09:09,659 --> 00:09:12,800
епозиториев. В методе Handle, который будет запускат

177
00:09:12,800 --> 00:09:15,941
ься при получении этого сообщения, я собираюсь  чтоб

178
00:09:15,941 --> 00:09:19,082
ы действительно получить GetEventDetailQuery;  это т

179
00:09:19,082 --> 00:09:22,223
от, который мы только что видели, содержащий идентиф

180
00:09:22,223 --> 00:09:25,364
икатор события, о котором я хочу получить информацию

181
00:09:25,364 --> 00:09:28,505
. Я снова собираюсь использовать свой _eventReposito

182
00:09:28,505 --> 00:09:31,645
ry, то есть мой общий репозиторий, и я собираюсь выз

183
00:09:31,645 --> 00:09:34,786
вать .GetByIdAsync, передав идентификатор  .Это верн

184
00:09:34,786 --> 00:09:37,927
ет или, по крайней мере, должно вернуть EventDetailV

185
00:09:37,927 --> 00:09:41,068
m. Поэтому я снова собираюсь использовать AutoMapper

186
00:09:41,068 --> 00:09:44,209
 для сопоставления с этим целевым типом. Теперь помн

187
00:09:44,209 --> 00:09:47,350
ите, что у меня также был здесь CategoryDto. Это не 

188
00:09:47,350 --> 00:09:50,491
 будет автоматически возвращен GetByIdAsync для собы

189
00:09:50,491 --> 00:09:53,632
тия. Поэтому мне также нужен мой _categoryRepository

190
00:09:53,632 --> 00:09:56,773
, чтобы получить категорию событий, и это то, что я 

191
00:09:56,773 --> 00:09:59,914
здесь делаю. Затем я использую другое сопоставление,

192
00:09:59,914 --> 00:10:03,055
 чтобы сопоставить сущность категории с CategoryDto,

193
00:10:03,055 --> 00:10:06,195
 а затем, наконец,  , я возвращаю свой EventDetail. 

194
00:10:06,195 --> 00:10:09,336
И это будет работать нормально, это скомпилируется, 

195
00:10:09,336 --> 00:10:12,477
но мне также нужно еще несколько сопоставлений, пото

196
00:10:12,477 --> 00:10:15,618
му что я добавил сюда сопоставление из Event в Event

197
00:10:15,618 --> 00:10:18,759
DetailVm и еще одно из Category в CategoryDto. Поэто

198
00:10:18,759 --> 00:10:21,900
му мне нужно вернуться назад.  в мой MappingProfile,

199
00:10:21,900 --> 00:10:25,041
 и мне нужно добавить сопоставление от Event к Event

200
00:10:25,041 --> 00:10:28,182
DetailVm и еще одно от Category к CategoryDto. Вот и

201
00:10:28,182 --> 00:10:31,323
 все.  С если они есть, то на самом деле все будет р

202
00:10:31,323 --> 00:10:34,464
аботать нормально. Мы пока не можем это проверить, н

203
00:10:34,464 --> 00:10:37,605
о увидим это позже. Я готов сделать еще кое-что.  В 

204
00:10:37,605 --> 00:10:40,745
своем проекте приложения я использовал nowMediatR и 

205
00:10:40,745 --> 00:10:43,886
AutoMapper.  Эти два пакета необходимо зарегистриров

206
00:10:43,886 --> 00:10:47,027
ать в коллекции сервисов моего приложения.  Теперь у

207
00:10:47,027 --> 00:10:50,168
 нас нет прямого доступа к коллекции сервисов внутри

208
00:10:50,168 --> 00:10:53,309
 моего приложения ASP.NET Core, которую вам все равн

209
00:10:53,309 --> 00:10:56,450
о придется добавить позже. Итак, я добавлю новый кла

210
00:10:56,450 --> 00:10:59,591
сс, который добавит расширение.  поверх этого класса

211
00:10:59,591 --> 00:11:02,732
 коллекции сервисов, используя метод расширения. Ита

212
00:11:02,732 --> 00:11:05,873
к, я собираюсь добавить новый класс под названием Ap

213
00:11:05,873 --> 00:11:09,014
plicationServiceRegistration. Итак, как вы можете ви

214
00:11:09,014 --> 00:11:12,155
деть, я превратил это в метод расширения onIServiceC

215
00:11:12,155 --> 00:11:15,295
ollection, и я  собираюсь зарегистрировать AutoMappe

216
00:11:15,295 --> 00:11:18,436
r и MediatR в коллекции служб. Также здесь я возвращ

217
00:11:18,436 --> 00:11:21,577
аю службы вызывающей стороне, которые мне понадобятс

218
00:11:21,577 --> 00:11:24,718
я позже в моем приложении ASP.NET Core, чтобы убедит

219
00:11:24,718 --> 00:11:27,859
ься, что AutoMapper и MediatR были правильно зарегис

220
00:11:27,859 --> 00:11:31,000
трированы. Теперь это  на месте. Давайте сделаем еще одну сборку, и, похоже, она работает нормально. Итак, здесь мы в хорошей форме.  Теперь вернемся к слайдам 

