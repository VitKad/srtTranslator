1
00:00:00,870 --> 00:00:03,270
Мы уже рассмотрели довольно много концепций. Вернемся 

2
00:00:03,270 --> 00:00:07,410
в Visual Studio и посмотрим, как все это реализовать. Мы добавим MediatR и AutoMapper. 

3
00:00:07,410 --> 00:00:10,100
Затем мы создадим запрос и обработчик запроса, 

4
00:00:10,100 --> 00:00:12,570
а также  наконец, мы подготовим все, чтобы наши библиотеки 

5
00:00:12,570 --> 00:00:13,520
могли быть зарегистрированы 

6
00:00:13,520 --> 00:00:16,470
в коллекции сервисов. Если бы мне платили за добавление 

7
00:00:16,470 --> 00:00:19,920
новых файлов и новых контрактов, то я бы 

8
00:00:19,920 --> 00:00:23,800
уже сегодня заработал немало денег, но только на контрактах, 

9
00:00:23,800 --> 00:00:26,860
это не очень полезно.  Нам нужно будет написать некоторый 

10
00:00:26,860 --> 00:00:29,930
код реализации, и это то, что я собираюсь сделать 

11
00:00:29,930 --> 00:00:33,120
дальше. Итак, теперь мы собираемся вместе написать бизнес-логику, 

12
00:00:33,120 --> 00:00:35,580
чтобы получить список всех событий, и давайте 

13
00:00:35,580 --> 00:00:37,250
сделаем это.  следующий. Итак, чтобы 

14
00:00:37,250 --> 00:00:40,420
написать наш бизнес-код, мне понадобится пара пакетов. На 

15
00:00:40,420 --> 00:00:43,300
самом деле я буду использовать 

16
00:00:43,300 --> 00:00:47,560
AutoMapper и MediatR, как описано на слайдах. AutoMapper будет использоваться для 

17
00:00:47,560 --> 00:00:50,160
сопоставления между сущностями, а MediatR будет 

18
00:00:50,160 --> 00:00:52,290
использоваться  использоваться для написания 

19
00:00:52,290 --> 00:00:56,080
этих запросов и обработчиков запросов, то есть сообщения 

20
00:00:56,080 --> 00:01:00,000
и обработчика сообщений. Чтобы упростить задачу, я перейду к своему проекту 

21
00:01:00,000 --> 00:01:03,630
приложения и внесу еще одну группу элементов, содержащую 

22
00:01:03,630 --> 00:01:06,420
ссылки на  пакеты, которые мне понадобятся. Поэтому я добавил 

23
00:01:06,420 --> 00:01:09,470
AutoMapper с расширением для внедрения зависимостей, а 

24
00:01:09,470 --> 00:01:13,420
также MediatR. Если я сохраню этот файл, 

25
00:01:13,420 --> 00:01:16,060
вы также сможете увидеть в диспетчере пакетов NuGet, что 

26
00:01:16,060 --> 00:01:19,380
эти пакеты действительно были добавлены 

27
00:01:19,380 --> 00:01:20,430
в мой проект. Итак,  

28
00:01:20,430 --> 00:01:24,280
сейчас я оберну то, что собираюсь сделать, в тип, и это будет 

29
00:01:24,280 --> 00:01:28,030
мой запрос, и я хочу получить все события в списке. 

30
00:01:28,030 --> 00:01:31,550
Итак, это происходит  быть, скажем, сообщением о том, что я хочу 

31
00:01:31,550 --> 00:01:33,740
сделать. Я хочу получить список всех 

32
00:01:33,740 --> 00:01:37,180
событий. Итак, я собираюсь обернуть это в тип, который 

33
00:01:37,180 --> 00:01:41,600
будет называться GetEventsListQuery, я  вызываю его запросом, потому 

34
00:01:41,600 --> 00:01:43,070
что я хочу что-то получить, и я хочу 

35
00:01:43,070 --> 00:01:45,190
получить этот список всех событий. Поэтому 

36
00:01:45,190 --> 00:01:49,210
мне нужно сделать этот класс сообщением, и я собираюсь 

37
00:01:49,210 --> 00:01:52,700
сделать это, разрешив ему реализовать интерфейс IRequest.  

38
00:01:52,700 --> 00:01:56,910
Параметр типа, то есть для IRequest, будет типом данных, 

39
00:01:56,910 --> 00:01:59,280
которые этот запрос будет возвращать, и 

40
00:01:59,280 --> 00:02:04,440
это будет список виртуальных машин со списком событий. Это еще один класс, 

41
00:02:04,440 --> 00:02:06,960
который я собираюсь  для возврата, и я собираюсь 

42
00:02:06,960 --> 00:02:07,780
создать определенный 

43
00:02:07,780 --> 00:02:11,850
тип ViewModel, который я собираюсь вернуть для своего клиентского приложения. 

44
00:02:11,850 --> 00:02:15,300
Это будет ViewModel, который будет содержать только 

45
00:02:15,300 --> 00:02:18,140
свойства для визуализации его в списке,  достаточно информации, 

46
00:02:18,140 --> 00:02:20,410
чтобы я не возвращал слишком много данных. 

47
00:02:20,410 --> 00:02:24,320
Это означает, что я добавлю сюда класс, потому что я его еще не создал. 

48
00:02:24,320 --> 00:02:27,230
Это будет новый класс, и он будет называться EventListVm, и 

49
00:02:27,230 --> 00:02:29,850
 как я уже сказал, он будет содержать данные, 

50
00:02:29,850 --> 00:02:34,740
которые я хочу визуализировать для события, когда оно отображается 

51
00:02:34,740 --> 00:02:38,150
в списке. Он содержит только несколько базовых свойств, а не все свойства события, 

52
00:02:38,150 --> 00:02:42,240
а только те, которые мне понадобятся.  в списке здесь Андур _____ здесь 

53
00:02:42,240 --> 00:02:45,300
тоже удовлетворен, так что это сообщение. Мне также 

54
00:02:45,300 --> 00:02:49,370
понадобится обработчик сообщения, который будет запускаться, скажем, 

55
00:02:49,370 --> 00:02:51,700
при отправке этого сообщения, и который будет 

56
00:02:51,700 --> 00:02:53,350
содержать фактическую бизнес-логику. 

57
00:02:53,350 --> 00:02:56,440
Итак  этот обработчик будет запускаться MediatR. 

58
00:02:56,440 --> 00:03:00,140
Итак, я собираюсь создать еще один класс, и это будет обработчик 

59
00:03:00,140 --> 00:03:02,960
GetEventsListQuery, обрабатывающий GetEventsListQuery. Это будет еще 

60
00:03:02,960 --> 00:03:05,320
один класс, который теперь должен реализовать 

61
00:03:05,320 --> 00:03:08,140
другой интерфейс из MediatR.  Итак, указав здесь, 

62
00:03:08,140 --> 00:03:11,190
что это реализует обработчик IRequesthandler в GetEventsListQuery, 

63
00:03:11,190 --> 00:03:12,950
это мой тип сообщения, и он будет возвращать 

64
00:03:12,950 --> 00:03:15,860
список виртуальных машин списка событий. Теперь он все 

65
00:03:15,860 --> 00:03:17,750
еще дает мне красную волнистую линию. 

66
00:03:17,750 --> 00:03:20,180
Это нормально, потому что мне все еще нужно реализовать 

67
00:03:20,180 --> 00:03:22,650
 метод, когда я собираюсь обработать сообщение, 

68
00:03:22,650 --> 00:03:25,880
и этот метод фактически называется Handle. Таким образом, 

69
00:03:25,880 --> 00:03:29,440
этот метод будет вызываться автоматически, когда aGetEventsListQuery 

70
00:03:29,440 --> 00:03:33,810
будет запущен, и этот обработчик подхватит его. Итак, он будет 

71
00:03:33,810 --> 00:03:36,340
содержать мою реализованную бизнес-логику 

72
00:03:36,340 --> 00:03:36,940
 здесь. Я вставил 

73
00:03:36,940 --> 00:03:39,740
код и позвольте мне теперь рассказать вам об этом. 

74
00:03:39,740 --> 00:03:43,940
В конструкторе я вхожу в картограф;  это AutoMapper, как вы можете видеть здесь. 

75
00:03:43,940 --> 00:03:46,620
Я также собираюсь использовать IAsyncRepository в событиях. 

76
00:03:46,620 --> 00:03:50,380
Действительно, этот обработчик запросов является моей бизнес-логикой, 

77
00:03:50,380 --> 00:03:54,640
и он будет работать с репозиториями, чтобы получить список событий. С конструктором 

78
00:03:54,640 --> 00:03:57,340
 инъекции, я собираюсь получить экземпляры _eventRepository и AutoMapper. 

79
00:03:57,340 --> 00:04:01,350
Теперь настоящее волшебство происходит здесь, в методе Handle, который 

80
00:04:01,350 --> 00:04:03,030
я установил. Я собираюсь 

81
00:04:03,030 --> 00:04:06,340
использовать свой репозиторий событий. На самом деле я собираюсь 

82
00:04:06,340 --> 00:04:08,560
использовать ListAllAsync  метод, который мы определили 

83
00:04:08,560 --> 00:04:12,090
в IAsyncRepository, то есть базовый интерфейс, и я собираюсь получить все 

84
00:04:12,090 --> 00:04:13,660
события, упорядоченные по дате. 

85
00:04:13,660 --> 00:04:18,590
Это дает мне список сущностей, IOrderedEnumerable событий, поэтому сущности 

86
00:04:18,590 --> 00:04:22,280
домена. Теперь я не хочу  для возврата объектов моим клиентам. Я хочу 

87
00:04:22,280 --> 00:04:24,560
возвращать объекты, которые я контролирую, 

88
00:04:24,560 --> 00:04:27,590
чтобы они содержали только те свойства, которые я хочу 

89
00:04:27,590 --> 00:04:29,540
вернуть, и они были доступны в моем EventListVm. 

90
00:04:29,540 --> 00:04:35,160
Теперь я не хочу писать сопоставление  Я тоже напишу код, поэтому я собираюсь 

91
00:04:35,160 --> 00:04:38,770
использовать для этого AutoMapper. И в AutoMapper я могу использовать 

92
00:04:38,770 --> 00:04:39,340
метод Map, как вы видите 

93
00:04:39,340 --> 00:04:43,220
здесь, и я могу указать тип, который я хочу сопоставить, 

94
00:04:43,220 --> 00:04:47,130
то есть список EventListVms  .И я собираюсь использовать allEvents 

95
00:04:47,130 --> 00:04:49,270
в качестве объекта, из которого я хочу сопоставить. 

96
00:04:49,270 --> 00:04:52,310
Итак, что будет возвращено, это список ViewModels 

97
00:04:52,310 --> 00:04:55,390
списка событий. Теперь AutoMapper нужна дополнительная 

98
00:04:55,390 --> 00:04:58,140
информация, чтобы это действительно работало. Это так. 

99
00:04:58,140 --> 00:05:01,300
 нужно то, что известно как профиль. Профиль будет содержать 

100
00:05:01,300 --> 00:05:04,000
информацию о сопоставлении, чтобы AutoMapper 

101
00:05:04,000 --> 00:05:05,700
знал, действительно ли он должен иметь 

102
00:05:05,700 --> 00:05:10,350
возможность попытаться сопоставить этот тип с другим типом. Теперь AutoMapper 

103
00:05:10,350 --> 00:05:15,040
выполняет большую часть работы автоматически, но иногда вам может потребоваться 

104
00:05:15,040 --> 00:05:19,190
помощь.  немного, но если свойства в EventListVm имеют те же имена, что и 

105
00:05:19,190 --> 00:05:21,560
свойства в реальном объекте, тогда он сам 

106
00:05:21,560 --> 00:05:24,750
выполнит сопоставление. Если мы затем просто создадим 

107
00:05:24,750 --> 00:05:27,940
профиль, сопоставление будет выполнено автоматически для 

108
00:05:27,940 --> 00:05:30,150
нас, если мы определим это  в профиле, 

109
00:05:30,150 --> 00:05:32,420
то есть. Итак, я собираюсь вернуться к своему проекту 

110
00:05:32,420 --> 00:05:34,920
приложения и создать папку с именем Profiles. 

111
00:05:34,920 --> 00:05:38,130
Теперь профиля действительно нечего бояться. Это просто 

112
00:05:38,130 --> 00:05:42,870
простой класс, который содержит  что AutoMapper должен знать с точки зрения 

113
00:05:42,870 --> 00:05:46,900
сопоставления между типами. Я назову это здесь классом MappingProfile. Как я уже 

114
00:05:46,900 --> 00:05:48,760
сказал, это просто класс, и он должен наследовать 

115
00:05:48,760 --> 00:05:51,100
от базового класса Profile. Это класс, который приходит 

116
00:05:51,100 --> 00:05:54,470
 с AutoMapper. В конструкторе я собираюсь написать 

117
00:05:54,470 --> 00:05:56,690
свои сопоставления. Я собираюсь создать сопоставление 

118
00:05:56,690 --> 00:06:00,650
между Event и EventListVm, и я собираюсь указать, что оно должно 

119
00:06:00,650 --> 00:06:03,380
иметь возможность знать об этом сопоставлении 

120
00:06:03,380 --> 00:06:06,540
двумя способами.  Итак, от Event к EventListVm и наоборот, 

121
00:06:06,540 --> 00:06:08,580
что я делаю здесь, используя ReverseMap. 

122
00:06:08,580 --> 00:06:11,560
По мере продвижения мы добавим больше профилей сопоставления. 

123
00:06:11,560 --> 00:06:14,270
Я хочу отметить здесь еще одну вещь. Итак, 

124
00:06:14,270 --> 00:06:17,520
мы можем видеть здесь, я  использовал IAsyncRepository 

125
00:06:17,520 --> 00:06:20,730
в Event. Конечно, у нас пока нет реализации;  который будет подключен 

126
00:06:20,730 --> 00:06:23,860
с помощью внедрения зависимостей, по сути, это реализация 

127
00:06:23,860 --> 00:06:26,280
инверсии зависимостей. Нам все еще нужно 

128
00:06:26,280 --> 00:06:29,530
написать реальный репозиторий, который знает, 

129
00:06:29,530 --> 00:06:32,040
как обрабатывать это в базе данных. Сейчас 

130
00:06:32,040 --> 00:06:35,650
у нас его еще нет, но вы можете увидеть это в приложении. 

131
00:06:35,650 --> 00:06:38,130
 проект, мы просто говорим с абстракцией. 

132
00:06:38,130 --> 00:06:42,370
Это то, что будет делать проект приложения, просто говорить с 

133
00:06:42,370 --> 00:06:43,230
абстракциями. 

134
00:06:43,230 --> 00:06:46,050
Я думаю, что на данный момент моя реализация GetEventList 

135
00:06:46,050 --> 00:06:48,490
более или менее готова. Надеюсь, вы уже 

136
00:06:48,490 --> 00:06:51,240
это поняли.  , и я собираюсь ввести еще один для получения 

137
00:06:51,240 --> 00:06:55,160
подробностей о событии и покажу вам результат. Теперь я 

138
00:06:55,160 --> 00:06:57,100
добавил несколько дополнительных классов, 

139
00:06:57,100 --> 00:07:00,690
которые будут использоваться для получения подробностей о событии.  Итак, у меня 

140
00:07:00,690 --> 00:07:03,070
есть еще один запрос, GetEventDetail, который 

141
00:07:03,070 --> 00:07:06,130
будет немного отличаться от нашего запроса GetEventsListQuery 

142
00:07:06,130 --> 00:07:08,740
в том смысле, что GetEventDetailQuery 

143
00:07:08,740 --> 00:07:13,880
содержит дополнительный параметр. Мне нужно знать, какие сведения о событии 

144
00:07:13,880 --> 00:07:16,090
мне нужно получить. Мы обернули его здесь. 

145
00:07:16,090 --> 00:07:19,600
 идентификатор Guid. Обратите внимание, что IRequest теперь будет универсальным 

146
00:07:19,600 --> 00:07:22,960
в EventDetailVm, поэтому тип возвращаемого 

147
00:07:22,960 --> 00:07:26,390
значения будет другой виртуальной машиной, 

148
00:07:26,390 --> 00:07:29,620
другой ViewModel, которая содержит больше свойств о событии, 

149
00:07:29,620 --> 00:07:33,000
то есть подробную информацию о событии. Обратите 

150
00:07:33,000 --> 00:07:36,140
внимание, что я  здесь есть вложенная сущность под названием 

151
00:07:36,140 --> 00:07:38,790
CategoryDto. Мне также нужно знать информацию 

152
00:07:38,790 --> 00:07:43,010
о категории этого события. Это другой тип. Это снова 

153
00:07:43,010 --> 00:07:46,780
не будет фактическая сущность категории, которую я собираюсь 

154
00:07:46,780 --> 00:07:49,320
вернуть. Я собираюсь  возвращать вложенную 

155
00:07:49,320 --> 00:07:54,840
категорию CategoryDto, содержащую идентификатор и имя этой категории, 

156
00:07:54,840 --> 00:07:58,530
которые мне нужно вернуть для получения подробной 

157
00:07:58,530 --> 00:08:02,830
информации о событии. Теперь сюда также включен обработчик GetEventDetailQuery, 

158
00:08:02,830 --> 00:08:05,480
и я расскажу вам и об этом. Это снова 

159
00:08:05,480 --> 00:08:09,780
обработчик IRequest, который  теперь будет инициироваться GetEventDetailQuery 

160
00:08:09,780 --> 00:08:14,450
и будет возвращать не список EventListVms, а один EventDetailVm. Мы 

161
00:08:14,450 --> 00:08:16,170
собираемся снова использовать 

162
00:08:16,170 --> 00:08:19,070
_eventRepository, но мы также собираемся использовать 

163
00:08:19,070 --> 00:08:20,360
_categoryRepository, и мы  собираюсь 

164
00:08:20,360 --> 00:08:25,180
снова использовать AutoMapper. Конструктор снова будет использовать внедрение 

165
00:08:25,180 --> 00:08:29,980
зависимостей, чтобы позже подключить конкретные реализации этих 

166
00:08:29,980 --> 00:08:33,820
репозиториев. В методе Handle, который будет запускаться при 

167
00:08:33,820 --> 00:08:36,040
получении этого сообщения, я собираюсь  чтобы 

168
00:08:36,040 --> 00:08:38,770
действительно получить GetEventDetailQuery;  это тот, который 

169
00:08:38,770 --> 00:08:40,700
мы только что видели, содержащий идентификатор 

170
00:08:40,700 --> 00:08:44,230
события, о котором я хочу получить информацию. Я снова 

171
00:08:44,230 --> 00:08:47,510
собираюсь использовать свой 

172
00:08:47,510 --> 00:08:49,540
_eventRepository, то есть мой общий репозиторий, 

173
00:08:49,540 --> 00:08:52,790
и я собираюсь вызвать .GetByIdAsync, передав идентификатор 

174
00:08:52,790 --> 00:08:55,850
 .Это вернет или, по крайней мере, должно вернуть 

175
00:08:55,850 --> 00:08:59,880
EventDetailVm. Поэтому я снова собираюсь использовать AutoMapper для сопоставления 

176
00:08:59,880 --> 00:09:03,900
с этим целевым типом. Теперь помните, что у меня также был здесь 

177
00:09:03,900 --> 00:09:05,450
CategoryDto. Это не  будет 

178
00:09:05,450 --> 00:09:08,460
автоматически возвращен GetByIdAsync для события. Поэтому мне 

179
00:09:08,460 --> 00:09:13,090
также нужен мой _categoryRepository, чтобы получить категорию событий, и это 

180
00:09:13,090 --> 00:09:16,880
то, что я здесь делаю. Затем я использую другое сопоставление, 

181
00:09:16,880 --> 00:09:18,780
чтобы сопоставить сущность категории с CategoryDto, 

182
00:09:18,780 --> 00:09:22,260
а затем, наконец,  , я возвращаю свой EventDetail. И это будет работать 

183
00:09:22,260 --> 00:09:24,540
нормально, это скомпилируется, 

184
00:09:24,540 --> 00:09:28,780
но мне также нужно еще несколько сопоставлений, потому что я добавил сюда 

185
00:09:28,780 --> 00:09:33,800
сопоставление из Event в EventDetailVm и еще одно из Category в CategoryDto. 

186
00:09:33,800 --> 00:09:37,420
Поэтому мне нужно вернуться назад.  в мой MappingProfile, 

187
00:09:37,420 --> 00:09:43,270
и мне нужно добавить сопоставление от Event к EventDetailVm и еще одно от Category 

188
00:09:43,270 --> 00:09:47,170
к CategoryDto. Вот и все.  С если они есть, то на самом деле все 

189
00:09:47,170 --> 00:09:48,860
будет работать нормально. Мы пока 

190
00:09:48,860 --> 00:09:53,670
не можем это проверить, но увидим это позже. Я готов сделать еще кое-что. 

191
00:09:53,670 --> 00:09:57,310
 В своем проекте приложения я использовал nowMediatR 

192
00:09:57,310 --> 00:10:00,410
и AutoMapper.  Эти два пакета необходимо зарегистрировать 

193
00:10:00,410 --> 00:10:03,540
в коллекции сервисов моего приложения.  Теперь у нас нет прямого 

194
00:10:03,540 --> 00:10:05,490
доступа к коллекции сервисов внутри моего 

195
00:10:05,490 --> 00:10:09,500
приложения ASP.NET Core, которую вам все равно 

196
00:10:09,500 --> 00:10:12,190
придется добавить позже. Итак, я добавлю новый класс, который 

197
00:10:12,190 --> 00:10:16,040
добавит расширение.  поверх этого класса коллекции сервисов, 

198
00:10:16,040 --> 00:10:18,480
используя метод расширения. Итак, 

199
00:10:18,480 --> 00:10:22,560
я собираюсь ввести новый класс под названием ApplicationServiceRegistration. 

200
00:10:22,560 --> 00:10:26,280
Итак, как вы можете видеть, я превратил это в метод 

201
00:10:26,280 --> 00:10:30,990
расширения onIServiceCollection, и я  собираюсь зарегистрировать AutoMapper 

202
00:10:30,990 --> 00:10:35,160
и MediatR в коллекции служб. Также здесь я возвращаю службы вызывающей стороне, 

203
00:10:35,160 --> 00:10:39,340
которые мне понадобятся позже в моем приложении ASP.NET Core, чтобы убедиться, 

204
00:10:39,340 --> 00:10:43,430
что AutoMapper и MediatR были правильно зарегистрированы. Теперь это  на 

205
00:10:43,430 --> 00:10:44,970
месте. Давайте сделаем еще одну сборку, 

206
00:10:44,970 --> 00:10:47,810
и, похоже, она работает нормально. Итак, здесь мы в хорошей 

207
00:10:47,810 --> 00:10:51,070
форме.  Теперь вернемся к слайдам 

208
00:10:51,070 --> 00:10:54,210


209
00:10:54,210 --> 00:10:59,070


210
00:10:59,070 --> 00:10:59,860


211
00:10:59,860 --> 00:11:02,400


212
00:11:02,400 --> 00:11:05,930


213
00:11:05,930 --> 00:11:09,290


214
00:11:09,290 --> 00:11:10,220


215
00:11:10,220 --> 00:11:15,160


216
00:11:15,160 --> 00:11:19,140


217
00:11:19,140 --> 00:11:22,680


218
00:11:22,680 --> 00:11:23,510


219
00:11:23,510 --> 00:11:27,550


220
00:11:27,550 --> 00:11:31,000


